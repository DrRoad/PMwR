plotTradingHours <- function(x, t = NULL,
                             interval = "5 min", labels = "hours",
                             label.format = NULL,
                             excludeWeekends = TRUE, holidays = NULL,
                             fromHHMMSS = "000000", toHHMMSS = "240000",
                             do.plotAxis = TRUE,
                             ...,
                             from = NULL, to = NULL,
                             do.plot = TRUE,
                             axis1.par = list()) {

    ## plot
    plot.par.def <- list(type = "l", xaxt = "n",
                         xlab = "", ylab = "")
    tmp <- list(...)
    plot.par.def[names(tmp)] <- tmp
    plot.par <- plot.par.def

    ## axis1
    axis1.par.def <- list(1, at = quote(pos),
                          labels = quote(format(grd[pos], fmt)))
    axis1.par.def[names(axis1.par)] <- axis1.par
    axis1.par <- axis1.par.def

    if (is.null(t)) {
        if (!inherits(x, "zoo"))
            stop(sQuote("t"), " not supplied, so ", sQuote("x"),
                 " must inherit from ", sQuote("zoo"))
        else {
            t <- index(x)
            x <- coredata(x)
        }
    } else {
        if (is.unsorted(t)) {
            idx <- order(t)
            t <- t[idx]
            x <- x[idx]
        }
    }

    ## check/prepare times
    fromHHMMSS <- makeHHMMSS(fromHHMMSS)
    toHHMMSS   <- makeHHMMSS(toHHMMSS)

    if (is.null(from))
        from <- roundPOSIXt(t[1L], interval)
    if (is.null(to))
        to <- roundPOSIXt(t[length(t)], interval)

    grd <- timegrid(from, to, interval = interval,
                    holidays = holidays,
                    fromHHMMSS = fromHHMMSS, toHHMMSS = toHHMMSS)
    
    ## aggregate data to grid (last)
    by <- roundPOSIXt(t, interval = interval)
    values <- last(x, by)
    t <- unique(by)
    
    ## match to grid
    ri <- match(grd, t, nomatch = 0L)
    rx <- match(t[ri], grd)
    values <- values[ri]    

    maptime <- function(t) {
        ## interval, grd in environment!
        by <- roundPOSIXt(t, interval = interval)
        t <- unique(by)
        ri <- match(grd, t, nomatch = 0L)
        rx <- match(t[ri], grd)
        list(t = rx, ix = ri[ri > 0])
    }
    
    ## prepare labels
    if (grepl("dayhour", labels, ignore.case = TRUE)) {
        pos <- which(abs(diff(as.POSIXlt(grd)$hour)) > 0) + 1
        fmt <- "%d.%m. %H:%M"
    } else if (grepl("hour", labels, ignore.case = TRUE)) {
        pos <- which(abs(diff(as.POSIXlt(grd)$hour)) > 0) + 1
        fmt <- "%H:%M"
    } else if (grepl("day", labels, ignore.case = TRUE)) {
        pos <- which(abs(diff(as.Date(grd))) > 0) + 1
        fmt <- "%d.%m."
    } else if (grepl("month", labels, ignore.case = TRUE)) {
        pos <- which(abs(diff(as.POSIXlt(grd)$mon)) > 0) + 1
        fmt <- "%d.%m."
    }
    
    if (do.plot) {
        do.call("plot", c(list(x = seq_len(length(grd))[rx],
                               y = values),
                          plot.par))

        if (do.plotAxis && length(axis1.par) && !is.na(axis1.par))
            do.call("axis", axis1.par)
        invisible(list(t = seq_len(length(grd))[rx],
                       x = values,
                       axis.pos = pos,
                       axis.labels = format(grd[pos], fmt),
                       timegrid = grd,
                       map = maptime))
    } else {
        list(t = seq_len(length(grd))[rx],
             x = values,
             axis.pos = pos,
             axis.labels = format(grd[pos], fmt),
             timegrid = grd,
             map = maptime)
    }
}
